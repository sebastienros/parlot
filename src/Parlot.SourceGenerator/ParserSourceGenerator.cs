using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.IO;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Parlot.SourceGeneration;
using RoslynCompilation = Microsoft.CodeAnalysis.Compilation;

namespace Parlot.SourceGenerator;

/// <summary>
/// Incremental source generator for Parlot grammars.
///
/// It looks for static methods annotated with <see cref="GenerateParserAttribute"/> that:
///   - are static
///   - return Parlot.Fluent.Parser&lt;T&gt;
/// It then:
///   - builds a temporary compilation including those methods,
///   - executes the descriptor methods to obtain Parser&lt;T&gt; instances,
///   - invokes ISourceable.GenerateSource on those instances,
///   - and emits optimized parse methods plus small wrapper Parser&lt;T&gt; types.
/// </summary>
[Generator]
public sealed class ParserSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Find candidate methods syntactically (methods with attributes).
        var methodDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => IsCandidateMethod(node),
            static (syntaxContext, _) => GetMethodToGenerate(syntaxContext))
            .Where(static m => m is not null)!;

        // 2. Combine the collected methods with the current Compilation.
        var compilationAndMethods = context.CompilationProvider.Combine(methodDeclarations.Collect());

        // 3. Register for source output.
        context.RegisterSourceOutput(compilationAndMethods, static (spc, source) =>
        {
            var (compilation, methods) = source;
            
            // Always output a debug file to confirm this runs
            spc.AddSource("ParlotDebugInfo.g.cs", SourceText.From(
                "// <auto-generated />\n" +
                "// Methods count: " + (methods.IsDefaultOrEmpty ? "0" : methods.Length.ToString(System.Globalization.CultureInfo.InvariantCulture)) + "\n" +
                "namespace Parlot.SourceGenerator.Internal;\n" +
                "internal static class DebugInfo { }\n", Encoding.UTF8));

            if (methods.IsDefaultOrEmpty)
            {
                return;
            }

            foreach (var m in methods)
            {
                if (m is null)
                {
                    continue;
                }

                try
                {
                    GenerateForMethod(spc, compilation, m.Value);
                }
                catch (Exception ex)
                {
                    spc.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT005",
                            "Error generating parser source",
                            "An error occurred while generating parser source for method '{0}': {1}",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        m.Value.Method.Locations.FirstOrDefault(),
                        m.Value.Method.Name,
                        ex.Message));
                    continue;
                }
            }
        });
    }

    private static bool IsCandidateMethod(SyntaxNode node)
        => node is MethodDeclarationSyntax m && m.AttributeLists.Count > 0;

    private static MethodToGenerate? GetMethodToGenerate(GeneratorSyntaxContext context)
    {
        var methodDecl = (MethodDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        var methodSymbol = semanticModel.GetDeclaredSymbol(methodDecl) as IMethodSymbol;
        if (methodSymbol is null)
        {
            return null;
        }

        var compilation = semanticModel.Compilation;
        var generateParserAttrSymbol = compilation.GetTypeByMetadataName("Parlot.SourceGenerator.GenerateParserAttribute");
        if (generateParserAttrSymbol is null)
        {
            return null;
        }

        var attrInfos = ImmutableArray.CreateBuilder<GenerateParserAttributeInfo>();

        foreach (var attr in methodSymbol.GetAttributes())
        {
            if (!SymbolEqualityComparer.Default.Equals(attr.AttributeClass, generateParserAttrSymbol))
            {
                continue;
            }

            string? factoryMethodName = null;
            ImmutableArray<TypedConstant> args = ImmutableArray<TypedConstant>.Empty;

            if (attr.ConstructorArguments.Length >= 1)
            {
                var first = attr.ConstructorArguments[0];
                if (first.Value is string s && !string.IsNullOrEmpty(s))
                {
                    factoryMethodName = s;
                }
            }

            if (attr.ConstructorArguments.Length >= 2)
            {
                var argArray = attr.ConstructorArguments[1];
                if (argArray.Kind == TypedConstantKind.Array)
                {
                    args = argArray.Values;
                }
            }
            else
            {
                // Some overloads may store arguments via params object[] as a single array arg when invoked via object[] literal
                // e.g., [GenerateParser("Name", new object?[] { 1, 2 })]
                // In that case, ConstructorArguments.Length == 1 but the attribute overload selected is the string+params or parameterless one.
                // We only treat the first argument as factory name when it is a string; otherwise, for parameterless overload the args remain empty.
            }

            var location = attr.ApplicationSyntaxReference?.GetSyntax().GetLocation();
            attrInfos.Add(new GenerateParserAttributeInfo(factoryMethodName, args, location));
        }

        if (attrInfos.Count == 0)
        {
            return null;
        }

        if (!methodSymbol.IsStatic)
        {
            return null;
        }

        if (!IsParserReturnType(methodSymbol.ReturnType))
        {
            return null;
        }

        return new MethodToGenerate(methodSymbol, attrInfos.ToImmutable());
    }

    private readonly record struct MethodToGenerate(IMethodSymbol Method, ImmutableArray<GenerateParserAttributeInfo> Attributes);
    private readonly record struct GenerateParserAttributeInfo(string? FactoryMethodName, ImmutableArray<TypedConstant> Arguments, Location? Location);

    private static bool IsParserReturnType(ITypeSymbol returnType)
    {
        if (returnType is not INamedTypeSymbol named || !named.IsGenericType)
        {
            return false;
        }

        var constructedFrom = named.ConstructedFrom;
        var display = constructedFrom.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        // Expect "global::Parlot.Fluent.Parser<T>"
        return display == "global::Parlot.Fluent.Parser<T>";
    }

    [SuppressMessage("Build", "RS1035", Justification = "The generator must execute parser descriptors to produce source output.")]
    private static void GenerateForMethod(
        SourceProductionContext context,
        RoslynCompilation hostCompilation,
        MethodToGenerate methodInfo)
    {
        var methodSymbol = methodInfo.Method;

        // Validate attribute names are unique for this method
        if (!ValidateUniqueAttributeNames(methodInfo, context))
        {
            return;
        }

        // Get the syntax tree containing this method
        var methodSyntaxRef = methodSymbol.DeclaringSyntaxReferences.FirstOrDefault();
        if (methodSyntaxRef is null)
        {
            return;
        }
        var methodSyntaxTree = methodSyntaxRef.SyntaxTree;
        var methodSyntax = methodSyntaxRef.GetSyntax() as MethodDeclarationSyntax;
        
        // Get semantic model for the syntax tree to resolve method groups
        var semanticModel = hostCompilation.GetSemanticModel(methodSyntaxTree);
        
        // Extract all lambda expressions from the method AND from static fields in the containing class
        // This allows source generation to work when parsers reference static fields with lambdas
        // Each entry contains: Source code, IsMethodGroup flag, InferredReturnType (for method groups, from semantic model)
        var lambdaSources = new Dictionary<string, (string Source, bool IsMethodGroup, string? ReturnType)>();
        if (methodSyntax is not null)
        {
            var lambdaIndex = 0;
            
            void ExtractLambdasAndMethodGroups(SyntaxNode root)
            {
                // Extract lambda expressions
                foreach (var lambda in root.DescendantNodes().OfType<LambdaExpressionSyntax>())
                {
                    var source = lambda.ToFullString().Trim();
                    var inferredReturn = InferReturnType(source);
                    lambdaSources[$"lambda_{lambdaIndex}"] = (source, IsMethodGroup: false, ReturnType: inferredReturn);
                    lambdaIndex++;
                }
                
                // Extract method group expressions used as delegate arguments
                // Look for invocations where a member access is passed as an argument (e.g., Pattern(char.IsLetterOrDigit))
                foreach (var invocation in root.DescendantNodes().OfType<InvocationExpressionSyntax>())
                {
                    foreach (var arg in invocation.ArgumentList.Arguments)
                    {
                        // Method groups appear as MemberAccessExpression when used as delegates
                        // e.g., char.IsLetterOrDigit, SomeClass.SomeMethod
                        if (arg.Expression is MemberAccessExpressionSyntax memberAccess)
                        {
                            var text = memberAccess.ToFullString().Trim();
                            
                            // Filter out property accesses and chained member access
                            // Method groups are typically simple: Type.Method (only one dot)
                            // and the method name typically starts with uppercase (Is, Has, Can, etc.)
                            var dotCount = text.Count(c => c == '.');
                            var memberName = memberAccess.Name.ToString();
                            
                            // Only include if:
                            // 1. Simple member access (one dot) like char.IsLetterOrDigit
                            // 2. Member name looks like a method (starts with capital letter or is a common predicate pattern)
                            if (dotCount == 1 && 
                                (char.IsUpper(memberName[0]) || memberName.StartsWith("is", StringComparison.OrdinalIgnoreCase)))
                            {
                                // Try to get the return type from the semantic model
                                string? methodReturnType = null;
                                var symbolInfo = semanticModel.GetSymbolInfo(memberAccess);
                                if (symbolInfo.Symbol is IMethodSymbol methodSym)
                                {
                                    methodReturnType = methodSym.ReturnType.Name.ToLowerInvariant();
                                }
                                else if (symbolInfo.CandidateSymbols.Length > 0 && 
                                         symbolInfo.CandidateSymbols[0] is IMethodSymbol candidateMethod)
                                {
                                    methodReturnType = candidateMethod.ReturnType.Name.ToLowerInvariant();
                                }
                                
                                lambdaSources[$"lambda_{lambdaIndex}"] = (text, IsMethodGroup: true, ReturnType: methodReturnType);
                                lambdaIndex++;
                            }
                        }
                    }
                }
            }
            
            // Extract from the method body
            ExtractLambdasAndMethodGroups(methodSyntax);
            
            // Also extract from static fields in the containing class
            var containingClass = methodSyntax.Parent as TypeDeclarationSyntax;
            if (containingClass is not null)
            {
                foreach (var member in containingClass.Members)
                {
                    if (member is FieldDeclarationSyntax fieldDecl && 
                        fieldDecl.Modifiers.Any(m => m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.StaticKeyword)))
                    {
                        ExtractLambdasAndMethodGroups(fieldDecl);
                    }
                }
            }
        }

        // Create a minimal compilation with only the file containing the parser descriptor.
        // This avoids errors from other files that reference generated code.
        var minimalSyntaxTrees = new List<SyntaxTree> { methodSyntaxTree };
        
        // Add a synthetic file with global usings that Parlot and typical projects provide.
        // This ensures the dynamic compilation works even when the user relies on implicit usings.
        var parseOptions = (CSharpParseOptions)methodSyntaxTree.Options;
        var globalUsings = CSharpSyntaxTree.ParseText(
            """
            // Parlot global usings for source generator dynamic compilation
            global using System;
            global using System.Collections.Generic;
            global using System.Linq;
            global using System.Threading.Tasks;
            global using Parlot;
            global using Parlot.Fluent;
            global using static Parlot.Fluent.Parsers;
            """,
            parseOptions,
            path: "ParlotGlobalUsings.g.cs");
        minimalSyntaxTrees.Add(globalUsings);
        
        var tempCompilation = hostCompilation
            .RemoveAllSyntaxTrees()
            .AddSyntaxTrees(minimalSyntaxTrees)
            .WithAssemblyName(hostCompilation.AssemblyName + ".ParlotGenTemp")
            .WithOptions(hostCompilation.Options.WithOutputKind(OutputKind.DynamicallyLinkedLibrary));

        using var peStream = new System.IO.MemoryStream();
        var emitResult = tempCompilation.Emit(peStream);

        if (!emitResult.Success)
        {
            // Output a diagnostic about emit failure with the error messages
            var errorMessages = string.Join("; ", emitResult.Diagnostics
                .Where(d => d.Severity == DiagnosticSeverity.Error)
                .Take(5)
                .Select(d => d.GetMessage(System.Globalization.CultureInfo.InvariantCulture)));
            
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("PARLOT001", "Emit failed", "Emit failed for method '{0}': {1}", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name, errorMessages));
            return;
        }

        // Success message is Info-level (won't break build)
        context.ReportDiagnostic(Diagnostic.Create(
            new DiagnosticDescriptor("PARLOT000", "Emit succeeded", "Emit succeeded for method '{0}'", "Parlot.SourceGenerator", DiagnosticSeverity.Info, true),
            methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name));

        peStream.Position = 0;

        // Build a dictionary of assembly paths from the compilation's references
        // This allows us to load assemblies that the project references
        var assemblyPaths = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        var pendingCompilationRefs = new List<(string Name, RoslynCompilation Compilation)>();
        var loadedAssemblies = new Dictionary<string, Assembly>(StringComparer.OrdinalIgnoreCase);
        
        // Debug: collect reference info
        var refDebugInfo = new List<string>();

        // First pass: collect all references
        foreach (var reference in hostCompilation.References)
        {
            if (reference is PortableExecutableReference peRef && peRef.FilePath is not null)
            {
                var assemblyName = Path.GetFileNameWithoutExtension(peRef.FilePath);
                var filePath = peRef.FilePath;
                
                // If this is a ref assembly (in obj/*/ref/), try to find the actual assembly
                // Ref assemblies are metadata-only and can't be loaded at runtime
                if (filePath.Contains(Path.DirectorySeparatorChar + "ref" + Path.DirectorySeparatorChar) ||
                    filePath.Contains("/ref/"))
                {
                    // Try to find the actual assembly in bin folder
                    // Path like: .../obj/Debug/net10.0/ref/Samples.dll -> .../bin/Debug/net10.0/Samples.dll
                    var objIndex = filePath.LastIndexOf(Path.DirectorySeparatorChar + "obj" + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase);
                    if (objIndex < 0) objIndex = filePath.LastIndexOf("/obj/", StringComparison.OrdinalIgnoreCase);
                    
                    if (objIndex >= 0)
                    {
                        var baseDir = filePath.Substring(0, objIndex);
                        var afterObj = filePath.Substring(objIndex + 4); // Skip "/obj"
                        var refIndex = afterObj.IndexOf(Path.DirectorySeparatorChar + "ref" + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase);
                        if (refIndex < 0) refIndex = afterObj.IndexOf("/ref/", StringComparison.OrdinalIgnoreCase);
                        
                        if (refIndex >= 0)
                        {
                            var configTfm = afterObj.Substring(0, refIndex); // e.g., "/Debug/net10.0"
                            var fileName = Path.GetFileName(filePath);
                            var binPath = baseDir + Path.DirectorySeparatorChar + "bin" + configTfm + Path.DirectorySeparatorChar + fileName;
                            
                            if (File.Exists(binPath))
                            {
                                filePath = binPath;
                            }
                        }
                    }
                }
                
                if (!assemblyPaths.ContainsKey(assemblyName))
                {
                    assemblyPaths[assemblyName] = filePath;
                }
                refDebugInfo.Add($"PE: {assemblyName} -> {filePath}");
            }
            else if (reference is CompilationReference compRef)
            {
                // For project references, we need to emit the referenced compilation to get an assembly
                var refCompilation = compRef.Compilation;
                var refAssemblyName = refCompilation.AssemblyName;
                refDebugInfo.Add($"Compilation: {refAssemblyName}");
                if (refAssemblyName is not null && refAssemblyName != "Parlot")
                {
                    pendingCompilationRefs.Add((refAssemblyName, refCompilation));
                }
            }
            else
            {
                refDebugInfo.Add($"Unknown: {reference.GetType().Name}");
            }
        }

        // Debug info removed - assembly loading working correctly

        // Set up an assembly resolver - needs to be set up BEFORE loading CompilationReference assemblies
        // because those assemblies may have their own dependencies
        ResolveEventHandler? resolver = null;
        resolver = (sender, args) =>
        {
            var requestedName = new AssemblyName(args.Name);
            if (requestedName.Name == "Parlot")
            {
                // Return the Parlot assembly that this generator is already using
                // This ensures ISourceable and other types have the same identity
                return typeof(Parlot.Fluent.Parser<>).Assembly;
            }

            // Try to return pre-loaded assembly from project references (CompilationReference)
            if (requestedName.Name is not null && loadedAssemblies.TryGetValue(requestedName.Name, out var loadedAssembly))
            {
                return loadedAssembly;
            }

            // Try to load from file-based references (PortableExecutableReference)
            if (requestedName.Name is not null && assemblyPaths.TryGetValue(requestedName.Name, out var path))
            {
                try
                {
                    var asm = Assembly.LoadFrom(path);
                    loadedAssemblies[requestedName.Name] = asm;
                    return asm;
                }
                catch
                {
                    // Fall through to return null
                }
            }

            return null;
        };

        AppDomain.CurrentDomain.AssemblyResolve += resolver;

        // Now load CompilationReference assemblies (with resolver active)
        foreach (var (refAssemblyName, refCompilation) in pendingCompilationRefs)
        {
            if (!loadedAssemblies.ContainsKey(refAssemblyName))
            {
                using var refPeStream = new MemoryStream();
                var refEmitResult = refCompilation.Emit(refPeStream);
                if (refEmitResult.Success)
                {
                    refPeStream.Position = 0;
                    try
                    {
                        var refAssembly = Assembly.Load(refPeStream.ToArray());
                        loadedAssemblies[refAssemblyName] = refAssembly;
                    }
                    catch (Exception ex)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            new DiagnosticDescriptor("PARLOT098", "Assembly load failed", "Failed to load '{0}': {1}", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                            methodSymbol.Locations.FirstOrDefault(), refAssemblyName, ex.Message));
                    }
                }
                else
                {
                    var errors = string.Join("; ", refEmitResult.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error).Take(3).Select(d => d.GetMessage(System.Globalization.CultureInfo.InvariantCulture)));
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor("PARLOT097", "Emit failed for ref", "Failed to emit '{0}': {1}", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                        methodSymbol.Locations.FirstOrDefault(), refAssemblyName, errors));
                }
            }
        }

        try
        {
            var assembly = Assembly.Load(peStream.ToArray());

            // Locate the generated type and method via reflection
            var containingTypeName = methodSymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            const string globalPrefix = "global::";
            if (containingTypeName.StartsWith(globalPrefix, StringComparison.Ordinal))
            {
                containingTypeName = containingTypeName.Substring(globalPrefix.Length);
            }

            var type = assembly.GetType(containingTypeName);
            if (type is null)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("PARLOT002", "Type not found", "Could not find type '{0}' in emitted assembly", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                    methodSymbol.Locations.FirstOrDefault(), containingTypeName));
                return;
            }

            var method = type.GetMethod(
                methodSymbol.Name,
                BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);

            if (method is null)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("PARLOT003", "Method not found", "Could not find method '{0}' on type '{1}'", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                    methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name, containingTypeName));
                return;
            }

            var methodParameters = method.GetParameters();

            var attributes = methodInfo.Attributes;
            for (int idx = 0; idx < attributes.Length; idx++)
            {
                var attrInfo = attributes[idx];
                var propertyName = attrInfo.FactoryMethodName;
                var variantSuffix = GetVariantSuffix(idx, propertyName);

                if (!TryBuildInvocationArguments(methodParameters, attrInfo.Arguments, methodSymbol, attrInfo.Location ?? methodSymbol.Locations.FirstOrDefault(), out var invocationArgs, out var diag))
                {
                    if (diag is not null)
                    {
                        context.ReportDiagnostic(diag);
                    }
                    continue;
                }

                object? parserInstance;
                try
                {
                    parserInstance = method.Invoke(null, invocationArgs);
                }
                catch (TargetInvocationException ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT004",
                            "Parser factory threw",
                            "Method '{0}' threw an exception while invoked with GenerateParser arguments: {1}",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        attrInfo.Location ?? methodSymbol.Locations.FirstOrDefault(),
                        methodSymbol.Name,
                        ex.InnerException?.Message ?? ex.Message));
                    continue;
                }
                catch (Exception ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT004",
                            "Parser factory failed",
                            "Method '{0}' could not be invoked: {1}",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        attrInfo.Location ?? methodSymbol.Locations.FirstOrDefault(),
                        methodSymbol.Name,
                        ex.Message));
                    continue;
                }

                if (parserInstance is null)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor("PARLOT004", "Null parser", "Method '{0}' returned null", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                        attrInfo.Location ?? methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name));
                    continue;
                }

                // The runtime type will be something like Parlot.Fluent.Then`2 or similar,
                // whose base type is Parser<T>.
                var parserType = parserInstance.GetType();
                var baseType = parserType.BaseType;
                if (baseType is null || !baseType.IsGenericType)
                {
                    continue;
                }

                var valueType = baseType.GetGenericArguments()[0];

                // Ensure the parser supports source generation
                if (parserInstance is not ISourceable sourceable)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT001",
                            "Parser does not implement ISourceable",
                            "Parser type '{0}' does not implement ISourceable. Implemented interfaces: {1}",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Warning,
                            isEnabledByDefault: true),
                        attrInfo.Location ?? methodSymbol.Locations.FirstOrDefault(),
                        parserInstance.GetType().FullName,
                        string.Join(", ", parserInstance.GetType().GetInterfaces().Select(i => i.FullName))));
                    continue;
                }

                var sgContext = new SourceGenerationContext(parseContextName: "context", methodNamePrefix: methodSymbol.Name + "_" + variantSuffix);
                var sourceResult = sourceable.GenerateSource(sgContext);

                // Generate C# code for this particular attribute variant
                var (sourceText, failedLambdas) = GenerateParserWrapperAndCore(methodSymbol, valueType, propertyName, variantSuffix, sourceResult, sgContext, lambdaSources);

                // Report errors for lambdas that couldn't be extracted
                foreach (var failedLambda in failedLambdas)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT002",
                            "Lambda extraction failed",
                            "Could not extract lambda from source for method '{0}': {1}. Define the parser inline in the [GenerateParser] method instead of referencing external static fields.",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        methodSymbol.Locations.FirstOrDefault(),
                        methodSymbol.Name,
                        failedLambda));
                }

                var hintName = $"{methodSymbol.ContainingType.Name}_{methodSymbol.Name}_{variantSuffix}.Parlot.g.cs";
                var dumpDirectory = Environment.GetEnvironmentVariable("PARLOT_DUMP_GEN_DIR");
                if (!string.IsNullOrEmpty(dumpDirectory))
                {
                    Directory.CreateDirectory(dumpDirectory);
                    File.WriteAllText(Path.Combine(dumpDirectory, hintName), sourceText);
                }
                context.AddSource(hintName, SourceText.From(sourceText, Encoding.UTF8));
            }
        }
        finally
        {
            AppDomain.CurrentDomain.AssemblyResolve -= resolver;
        }
    }

    private static (string SourceText, List<string> FailedLambdas) GenerateParserWrapperAndCore(
        IMethodSymbol methodSymbol,
        Type valueType,
        string? propertyName,
        string variantSuffix,
        SourceResult result,
        SourceGenerationContext sgContext,
        Dictionary<string, (string Source, bool IsMethodGroup, string? ReturnType)> lambdaSources)
    {
        var ns = methodSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : methodSymbol.ContainingNamespace.ToDisplayString();

        var typeName = methodSymbol.ContainingType.Name;
        var methodName = methodSymbol.Name;
        var valueTypeName = TypeNameHelper.GetTypeName(valueType);
        var coreName = methodName + "_" + variantSuffix + "_Core";
        var wrapperName = "GeneratedParser_" + methodName + "_" + variantSuffix;

        // First pass: process all deferred parsers to collect all lambdas
        // We need to do this before emitting lambda fields
        var deferredMethods = new List<(string MethodName, string ValueTypeName, SourceResult Result)>();
        var processedDeferred = new HashSet<object>();
        var deferredToProcess = sgContext.Deferred.Enumerate().ToList();
        
        while (deferredToProcess.Count > 0)
        {
            var (parser, deferredMethodName) = deferredToProcess[0];
            deferredToProcess.RemoveAt(0);
            
            if (processedDeferred.Contains(parser))
            {
                continue;
            }
            processedDeferred.Add(parser);

            if (parser is not ISourceable sourceable)
            {
                continue;
            }

            // Get the parser type to determine how to process it
            var parserType = parser.GetType();
            
            // Find the result type from Parser<T> base class
            Type? deferredValueType = null;
            var currentType = parserType;
            while (currentType != null)
            {
                if (currentType.IsGenericType)
                {
                    var genericDef = currentType.GetGenericTypeDefinition();
                    if (genericDef.FullName == "Parlot.Fluent.Parser`1")
                    {
                        deferredValueType = currentType.GetGenericArguments()[0];
                        break;
                    }
                }
                currentType = currentType.BaseType;
            }

            if (deferredValueType is null)
            {
                continue;
            }

            var deferredValueTypeName = TypeNameHelper.GetTypeName(deferredValueType);

            // For Deferred<T> parsers, generate source for the inner parser
            // For other parsers (like Unary<T>), generate source for the parser itself
            SourceResult deferredResult;
            if (parserType.IsGenericType && parserType.GetGenericTypeDefinition().Name == "Deferred`1")
            {
                // Get the inner parser from the Deferred
                var parserProperty = parserType.GetProperty("Parser");
                if (parserProperty is null)
                {
                    continue;
                }

                var innerParser = parserProperty.GetValue(parser);
                if (innerParser is not ISourceable innerSourceable)
                {
                    continue;
                }

                // Generate source for the inner parser
                deferredResult = innerSourceable.GenerateSource(sgContext);
            }
            else
            {
                // For other deferred parsers (like Unary), generate source directly
                deferredResult = sourceable.GenerateSource(sgContext);
            }
            
            deferredMethods.Add((deferredMethodName, deferredValueTypeName, deferredResult));
            
            // Check for new deferred parsers that were added
            foreach (var newDeferred in sgContext.Deferred.Enumerate())
            {
                if (!processedDeferred.Contains(newDeferred.Parser) && !deferredToProcess.Any(d => d.Parser == newDeferred.Parser))
                {
                    deferredToProcess.Add(newDeferred);
                }
            }
        }

        // Collect helper methods (OneOf, etc.) after all parsers/deferred have been processed
        var helperMethods = sgContext.Helpers.Enumerate().ToList();

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable annotations");
        sb.AppendLine("#nullable disable warnings");
        sb.AppendLine("using System;");
        sb.AppendLine("using Parlot;");
        sb.AppendLine("using Parlot.Fluent;");

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine();
            sb.Append("namespace ").Append(ns).AppendLine();
            sb.AppendLine("{");
        }

        sb.AppendLine($"    partial class {typeName}");
        sb.AppendLine("    {");

        // Now emit lambda fields - this includes lambdas from both the main parser and all deferred parsers
        // We need to match lambdas by their signature since runtime traversal order may differ from source order
        var lambdaSourcesList = lambdaSources.OrderBy(kv => kv.Key).Select(kv => kv.Value).ToList();
        var registeredLambdas = sgContext.Lambdas.Enumerate().OrderBy(x => x.Id).ToList();
        
        // Track which source lambdas have been used and which failed
        var usedSourceIndices = new HashSet<int>();
        var failedLambdas = new List<string>();

        foreach (var (id, del) in registeredLambdas)
        {
            var fieldName = sgContext.GetLambdaFieldName(id);
            var delegateType = del.GetType();
            var delegateTypeName = TypeNameHelper.GetTypeName(delegateType);
            
            // Get delegate info for matching
            var invokeMethod = delegateType.GetMethod("Invoke");
            var paramCount = invokeMethod?.GetParameters().Length ?? 0;
            var returnType = invokeMethod?.ReturnType;
            var returnTypeName = returnType?.Name.ToLowerInvariant() ?? "";
            
            // Get parameter type names for matching
            var paramTypeNames = new List<string>();
            if (invokeMethod is not null)
            {
                foreach (var p in invokeMethod.GetParameters())
                {
                    paramTypeNames.Add(p.ParameterType.Name.ToLowerInvariant());
                }
            }
            
            // Try to find the best matching source lambda
            string? matchedSource = null;
            int bestMatchIndex = -1;
            int bestScore = -1;
            
            for (int i = 0; i < lambdaSourcesList.Count; i++)
            {
                if (usedSourceIndices.Contains(i))
                {
                    continue;
                }
                
                var (lambdaSource, isMethodGroup, storedReturnType) = lambdaSourcesList[i];
                var sourceParamCount = CountLambdaParameters(lambdaSource);
                
                // For method groups, we can't determine param count from source
                // So we allow them to potentially match any single-param delegate
                if (!isMethodGroup && sourceParamCount != paramCount)
                {
                    continue;
                }
                
                // For method groups, verify the return type matches (from semantic model)
                if (isMethodGroup)
                {
                    // If we have return type info from semantic model, it must match
                    if (storedReturnType is not null && 
                        !string.Equals(storedReturnType, returnTypeName, StringComparison.OrdinalIgnoreCase))
                    {
                        continue; // Skip - return type doesn't match
                    }
                }
                
                // Calculate a score based on type name hints in the lambda
                int score = 0;
                var lowerLambda = lambdaSource.ToLowerInvariant();
                
                // Check for type hints in the lambda body
                foreach (var typeName_ in paramTypeNames)
                {
                    if (lowerLambda.Contains(typeName_))
                    {
                        score += 10;
                    }
                }
                
                // Use the stored return type (from semantic model for method groups, or inferred for lambdas)
                var effectiveReturnType = storedReturnType ?? InferReturnType(lambdaSource);
                if (effectiveReturnType is not null && 
                    string.Equals(effectiveReturnType, returnTypeName, StringComparison.OrdinalIgnoreCase))
                {
                    score += 25; // Strong preference for matching return types
                }
                
                // Prefer lambdas that haven't been used and match param count exactly
                score += (paramCount == sourceParamCount) ? 5 : 0;
                
                if (score > bestScore)
                {
                    bestScore = score;
                    bestMatchIndex = i;
                    matchedSource = lambdaSource;
                }
            }
            
            if (matchedSource is not null && bestMatchIndex >= 0)
            {
                usedSourceIndices.Add(bestMatchIndex);
                
                // Generate a method instead of a delegate field for better performance
                var methodSource = GenerateLambdaMethod(fieldName, invokeMethod!, matchedSource);
                sb.AppendLine(methodSource);
            }
            else
            {
                // Cannot generate source for external lambdas - track for error reporting
                var errorMsg = $"Lambda {id} (param count: {paramCount}, types: {string.Join(", ", paramTypeNames)})";
                failedLambdas.Add(errorMsg);
                
                sb.AppendLine($"        // ERROR: Lambda {id} could not be extracted from source (param count: {paramCount}, types: {string.Join(", ", paramTypeNames)}).");
                sb.AppendLine($"        // This lambda may be from an external parser or was not found in the method's syntax tree.");
                sb.AppendLine($"        // To fix: define the parser inline in the [GenerateParser] method.");
                
                // Generate a throwing method for error cases
                var errorReturnTypeName = TypeNameHelper.GetTypeName(invokeMethod!.ReturnType);
                var errorParamList = GenerateParameterList(invokeMethod);
                sb.AppendLine($"        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine($"        private static {errorReturnTypeName} {fieldName}({errorParamList}) => throw new global::System.InvalidOperationException(\"Lambda could not be extracted from source\");");
            }
        }

        sb.AppendLine($"        private sealed class {wrapperName} : Parser<{valueTypeName}>");
        sb.AppendLine("        {");
        sb.AppendLine($"            public override bool Parse(ParseContext context, ref ParseResult<{valueTypeName}> result)");
        sb.AppendLine("            {");
        sb.AppendLine($"                return {coreName}(context, ref result);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"        internal static bool {coreName}(ParseContext context, ref ParseResult<{valueTypeName}> result)");
        sb.AppendLine("        {");
        sb.AppendLine("            var scanner = context.Scanner;");
        sb.AppendLine("            var cursor = scanner.Cursor;");
        
        // Always capture initial offset for parsers that don't skip whitespace
        if (result.ContentStartOffsetVariable == null)
        {
            sb.AppendLine("            var startOffset = cursor.Offset;");
        }
        
        sb.AppendLine();

        // Check if the parser body uses early returns (optimized literals)
        var coreBodyContainsReturn = result.Body.Any(stmt => stmt.TrimStart().StartsWith("return ", StringComparison.Ordinal));
        
        if (coreBodyContainsReturn)
        {
            // Parsers with early returns need special handling in Core:
            // 1. Declare the value variable they reference
            // 2. Convert "return true" to set result and return
            // 3. Convert "return false" to just return false
            
            sb.AppendLine($"            {valueTypeName} {result.ValueVariable} = default;");
            
            var startOffsetExpr = result.ContentStartOffsetVariable ?? "startOffset";
            
            foreach (var stmt in result.Body)
            {
                var trimmed = stmt.TrimStart();
                if (trimmed == "return true;")
                {
                    // Convert early success return to set result and return
                    sb.AppendLine($"            result = new ParseResult<{valueTypeName}>({startOffsetExpr}, cursor.Offset, {result.ValueVariable});");
                    sb.AppendLine("            return true;");
                }
                else if (trimmed == "return false;")
                {
                    sb.AppendLine("            return false;");
                }
                else
                {
                    sb.Append("            ").AppendLine(stmt);
                }
            }
        }
        else
        {
            foreach (var local in result.Locals)
            {
                sb.Append("            ").AppendLine(local);
            }

            foreach (var stmt in result.Body)
            {
                sb.Append("            ").AppendLine(stmt);
            }

            sb.AppendLine();
            sb.AppendLine($"            if ({result.SuccessVariable})");
            sb.AppendLine("            {");
            
            // Use ContentStartOffsetVariable if available (for parsers that skip whitespace),
            // otherwise use the captured startOffset
            var startOffsetExpr = result.ContentStartOffsetVariable ?? "startOffset";
            
            sb.AppendLine($"                result = new ParseResult<{valueTypeName}>({startOffsetExpr}, cursor.Offset, {result.ValueVariable});");
            sb.AppendLine("                return true;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            return false;");
        }
        sb.AppendLine("        }");

        // Emit helper methods for deferred parsers (already processed earlier)
        foreach (var (deferredMethodName, deferredValueTypeName, deferredResult) in deferredMethods)
        {
            sb.AppendLine();
            sb.AppendLine($"        private static bool {deferredMethodName}(ParseContext context, out {deferredValueTypeName} value)");
            sb.AppendLine("        {");
            sb.AppendLine("            var scanner = context.Scanner;");
            sb.AppendLine("            var cursor = scanner.Cursor;");
            sb.AppendLine();

            foreach (var local in deferredResult.Locals)
            {
                sb.Append("            ").AppendLine(local);
            }

            foreach (var stmt in deferredResult.Body)
            {
                sb.Append("            ").AppendLine(stmt);
            }

            // Only add final return if the body doesn't already contain returns (e.g., optimized literal parsers use early returns)
            var bodyContainsReturn = deferredResult.Body.Any(stmt => stmt.TrimStart().StartsWith("return ", StringComparison.Ordinal));
            if (!bodyContainsReturn)
            {
                sb.AppendLine();
                sb.AppendLine($"            value = {deferredResult.ValueVariable};");
                sb.AppendLine($"            return {deferredResult.SuccessVariable};");
            }
            sb.AppendLine("        }");
        }

        // Emit helper methods registered via ParserHelperRegistry (e.g., OneOf buckets)
        foreach (var (helperMethodName, helperValueTypeName, helperResult) in helperMethods)
        {
            sb.AppendLine();
            sb.AppendLine($"        private static bool {helperMethodName}(ParseContext context, out {helperValueTypeName} value)");
            sb.AppendLine("        {");
            sb.AppendLine("            var scanner = context.Scanner;");
            sb.AppendLine("            var cursor = scanner.Cursor;");
            sb.AppendLine();

            foreach (var local in helperResult.Locals)
            {
                sb.Append("            ").AppendLine(local);
            }

            foreach (var stmt in helperResult.Body)
            {
                sb.Append("            ").AppendLine(stmt);
            }

            // Only add final return if the body doesn't already contain returns (e.g., optimized literal parsers use early returns)
            var bodyContainsReturn = helperResult.Body.Any(stmt => stmt.TrimStart().StartsWith("return ", StringComparison.Ordinal));
            if (!bodyContainsReturn)
            {
                sb.AppendLine();
                sb.AppendLine($"            value = {helperResult.ValueVariable};");
                sb.AppendLine($"            return {helperResult.SuccessVariable};");
            }
            sb.AppendLine("        }");
        }
        sb.AppendLine();

        // Optional public factory, if the attribute specified one.
        if (!string.IsNullOrEmpty(propertyName))
        {
            sb.AppendLine();
            sb.AppendLine("        public static Parlot.Fluent.Parser<" + valueTypeName + "> " + propertyName + " { get; } = new " + wrapperName + "();");
        }
        else
        {
            sb.AppendLine();
            sb.AppendLine("        public static Parlot.Fluent.Parser<" + valueTypeName + "> " + methodName + "_Parser { get; } = new " + wrapperName + "();");
            sb.AppendLine();
        }

        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine("}");
        }

        return (sb.ToString(), failedLambdas);
    }

    private static bool ValidateUniqueAttributeNames(MethodToGenerate methodInfo, SourceProductionContext context)
    {
        var methodSymbol = methodInfo.Method;
        var attributes = methodInfo.Attributes;
        var nameMap = new Dictionary<string, GenerateParserAttributeInfo>(StringComparer.Ordinal);

        for (int i = 0; i < attributes.Length; i++)
        {
            var attr = attributes[i];
            var propName = attr.FactoryMethodName ?? (methodSymbol.Name + "_Parser");

            if (nameMap.TryGetValue(propName, out var existing))
            {
                var descriptor = new DiagnosticDescriptor(
                    "PARLOT010",
                    "Duplicate GenerateParser name",
                    "GenerateParser attributes on method '{0}' must have unique names. Duplicate name: '{1}'.",
                    "Parlot.SourceGenerator",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true);

                context.ReportDiagnostic(Diagnostic.Create(descriptor, attr.Location ?? methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name, propName));
                context.ReportDiagnostic(Diagnostic.Create(descriptor, existing.Location ?? methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name, propName));
                return false;
            }

            nameMap[propName] = attr;
        }

        return true;
    }

    private static bool TryBuildInvocationArguments(
        ParameterInfo[] parameters,
        ImmutableArray<TypedConstant> arguments,
        IMethodSymbol methodSymbol,
        Location? location,
        out object?[] invocationArgs,
        out Diagnostic? diagnostic)
    {
        diagnostic = null;
        invocationArgs = Array.Empty<object?>();

        if (parameters.Length != arguments.Length)
        {
            diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    "PARLOT006",
                    "Argument count mismatch",
                    "GenerateParser arguments for method '{0}' did not match parameter count. Expected {1}, got {2}.",
                    "Parlot.SourceGenerator",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                location ?? methodSymbol.Locations.FirstOrDefault(),
                methodSymbol.Name,
                parameters.Length,
                arguments.Length);
            return false;
        }

        var args = new object?[arguments.Length];
        for (int i = 0; i < arguments.Length; i++)
        {
            var param = parameters[i];
            var paramType = param.ParameterType;
            var constant = arguments[i];
            var value = constant.Value;

            if (value is null)
            {
                if (paramType.IsValueType && Nullable.GetUnderlyingType(paramType) is null)
                {
                    diagnostic = Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT007",
                            "Null argument",
                            "GenerateParser argument for parameter '{0}' cannot be null.",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        location ?? methodSymbol.Locations.FirstOrDefault(),
                        param.Name ?? $"arg{i}");
                    return false;
                }

                args[i] = null;
                continue;
            }

            if (paramType.IsInstanceOfType(value))
            {
                args[i] = value;
                continue;
            }

            if (paramType == typeof(Type) && value is ITypeSymbol ts)
            {
                var typeDisplay = ts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var runtimeType = Type.GetType(typeDisplay);
                if (runtimeType is null)
                {
                    diagnostic = Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT008",
                            "Type argument resolution failed",
                            "Could not resolve type '{0}' for parameter '{1}'.",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        location ?? methodSymbol.Locations.FirstOrDefault(),
                        typeDisplay,
                        param.Name ?? $"arg{i}");
                    return false;
                }

                args[i] = runtimeType;
                continue;
            }

            try
            {
                // Attempt simple numeric/string conversions when possible
                args[i] = Convert.ChangeType(value, paramType, System.Globalization.CultureInfo.InvariantCulture);
                continue;
            }
            catch
            {
                diagnostic = Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "PARLOT009",
                        "Unsupported argument type",
                        "GenerateParser argument at position {0} (type '{1}') cannot be converted to parameter '{2}' of type '{3}'.",
                        "Parlot.SourceGenerator",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    location ?? methodSymbol.Locations.FirstOrDefault(),
                    i,
                    value.GetType().FullName,
                    param.Name ?? $"arg{i}",
                    paramType.FullName);
                return false;
            }
        }

        invocationArgs = args;
        return true;
    }

    private static string GetVariantSuffix(int index, string? propertyName)
    {
        var baseName = string.IsNullOrWhiteSpace(propertyName) ? "Parser" : propertyName!;
        return $"v{index}_{SanitizeIdentifier(baseName)}";
    }

    private static string SanitizeIdentifier(string raw)
    {
        if (string.IsNullOrEmpty(raw))
        {
            return "_";
        }

        var sb = new StringBuilder(raw.Length);
        for (int i = 0; i < raw.Length; i++)
        {
            var ch = raw[i];
            if ((ch >= 'a' && ch <= 'z') ||
                (ch >= 'A' && ch <= 'Z') ||
                (ch >= '0' && ch <= '9') ||
                ch == '_')
            {
                sb.Append(ch);
            }
            else
            {
                sb.Append('_');
            }
        }

        if (sb.Length == 0)
        {
            return "_";
        }

        if (sb[0] >= '0' && sb[0] <= '9')
        {
            sb.Insert(0, '_');
        }

        return sb.ToString();
    }

    /// <summary>
    /// Count parameters in a lambda expression source string.
    /// Examples:
    ///   "x => ..." -> 1
    ///   "(x) => ..." -> 1
    ///   "(a, b) => ..." -> 2
    ///   "() => ..." -> 0
    ///   "static x => ..." -> 1
    /// </summary>
    private static int CountLambdaParameters(string lambdaSource)
    {
        // Remove "static " prefix if present
        var source = lambdaSource.TrimStart();
        if (source.StartsWith("static ", StringComparison.Ordinal))
        {
            source = source.Substring(7).TrimStart();
        }

        // Find the arrow "=>"
        var arrowIndex = source.IndexOf("=>", StringComparison.Ordinal);
        if (arrowIndex < 0)
        {
            return 0;
        }

        var paramPart = source.Substring(0, arrowIndex).Trim();

        // Empty parameter list: () => ...
        if (paramPart == "()")
        {
            return 0;
        }

        // Single identifier without parens: x => ...
        if (!paramPart.StartsWith("(", StringComparison.Ordinal))
        {
            // It's a single identifier
            return 1;
        }

        // Has parentheses: (x) or (a, b) or (a, b, c)
        // Remove the parens
        if (paramPart.StartsWith("(", StringComparison.Ordinal) && paramPart.EndsWith(")", StringComparison.Ordinal))
        {
            paramPart = paramPart.Substring(1, paramPart.Length - 2).Trim();
        }

        if (string.IsNullOrEmpty(paramPart))
        {
            return 0;
        }

        // Count commas + 1
        var commaCount = paramPart.Count(c => c == ',');
        return commaCount + 1;
    }

    /// <summary>
    /// Generates a method from a lambda source or method group.
    /// Transforms "static x => 'w'" into "private static char MethodName(TextSpan x) => 'w';"
    /// Transforms "char.IsLetterOrDigit" into "private static bool MethodName(char x) => char.IsLetterOrDigit(x);"
    /// </summary>
    private static string GenerateLambdaMethod(string methodName, System.Reflection.MethodInfo invokeMethod, string lambdaSource)
    {
        var sb = new StringBuilder();
        var returnTypeName = TypeNameHelper.GetTypeName(invokeMethod.ReturnType);
        var parameters = invokeMethod.GetParameters();
        
        // Check if it's a method group (no =>) or a lambda
        var isMethodGroup = !lambdaSource.Contains("=>");
        
        // Generate parameter list with types
        var paramList = GenerateParameterList(invokeMethod);
        
        if (isMethodGroup)
        {
            // For method groups like "char.IsLetterOrDigit", generate a call
            // private static bool _lambda0(char x) => char.IsLetterOrDigit(x);
            sb.Append("        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]\n");
            sb.Append($"        private static {returnTypeName} {methodName}({paramList}) => ");
            sb.Append(lambdaSource);
            sb.Append('(');
            for (int i = 0; i < parameters.Length; i++)
            {
                if (i > 0) sb.Append(", ");
                sb.Append(GetParameterName(i));
            }
            sb.Append(");");
        }
        else
        {
            // For lambdas, extract the body
            // "static x => 'w'" becomes "'w'"
            var source = lambdaSource.TrimStart();
            if (source.StartsWith("static ", StringComparison.Ordinal))
            {
                source = source.Substring(7).TrimStart();
            }
            
            var arrowIndex = source.IndexOf("=>", StringComparison.Ordinal);
            if (arrowIndex >= 0)
            {
                var body = source.Substring(arrowIndex + 2).Trim();
                var paramPart = source.Substring(0, arrowIndex).Trim();
                
                // Check if it's a block lambda (body starts with {)
                var isBlockLambda = body.StartsWith("{", StringComparison.Ordinal);
                
                if (isBlockLambda)
                {
                    // Block lambda - generate a method with body
                    // Need to replace parameter references in the body
                    body = ReplaceParameterNames(body, paramPart, parameters.Length);
                    
                    sb.Append($"        private static {returnTypeName} {methodName}({paramList})\n");
                    sb.Append("        ");
                    sb.Append(body);
                }
                else
                {
                    // Expression lambda - use expression-bodied method
                    body = ReplaceParameterNames(body, paramPart, parameters.Length);
                    
                    sb.Append("        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]\n");
                    sb.Append($"        private static {returnTypeName} {methodName}({paramList}) => ");
                    sb.Append(body);
                    if (!body.EndsWith(";", StringComparison.Ordinal))
                    {
                        sb.Append(';');
                    }
                }
            }
            else
            {
                sb.Append("        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]\n");
                sb.Append($"        private static {returnTypeName} {methodName}({paramList}) => default!;");
            }
        }
        
        return sb.ToString();
    }
    
    /// <summary>
    /// Generates a parameter list like "TextSpan arg0, char arg1".
    /// </summary>
    private static string GenerateParameterList(System.Reflection.MethodInfo invokeMethod)
    {
        var parameters = invokeMethod.GetParameters();
        var sb = new StringBuilder();
        
        for (int i = 0; i < parameters.Length; i++)
        {
            if (i > 0) sb.Append(", ");
            var paramTypeName = TypeNameHelper.GetTypeName(parameters[i].ParameterType);
            sb.Append(paramTypeName);
            sb.Append(' ');
            sb.Append(GetParameterName(i));
        }
        
        return sb.ToString();
    }
    
    /// <summary>
    /// Gets a standard parameter name for index i.
    /// </summary>
    private static string GetParameterName(int index) => index == 0 ? "arg0" : $"arg{index}";
    
    /// <summary>
    /// Replaces parameter names in the lambda body with standard names.
    /// For "x => x.Length" with 1 param, replaces "x" with "arg0".
    /// For tuple deconstruction "(a, b) => ...", adds a deconstruction statement if it's a block.
    /// </summary>
    private static string ReplaceParameterNames(string body, string paramPart, int paramCount)
    {
        if (paramCount == 0) return body;
        
        // Remove parentheses if present
        paramPart = paramPart.Trim();
        var hadParens = paramPart.StartsWith("(", StringComparison.Ordinal) && paramPart.EndsWith(")", StringComparison.Ordinal);
        if (hadParens)
        {
            paramPart = paramPart.Substring(1, paramPart.Length - 2).Trim();
        }
        
        // Check for tuple deconstruction pattern - multiple names but single param
        var commaCount = paramPart.Count(c => c == ',');
        var isTupleDeconstruction = paramCount == 1 && commaCount > 0;
        
        if (isTupleDeconstruction)
        {
            // Tuple deconstruction case: (a, b) => { ... } with single tuple param
            // We need to add a deconstruction line at the start of the body
            var isBlockBody = body.TrimStart().StartsWith("{", StringComparison.Ordinal);
            if (isBlockBody)
            {
                // Find the opening brace and insert deconstruction after it
                var braceIndex = body.IndexOf('{');
                if (braceIndex >= 0)
                {
                    var deconstructLine = $"\n            var ({paramPart}) = arg0;";
                    body = body.Insert(braceIndex + 1, deconstructLine);
                }
            }
            else
            {
                // Expression body with tuple deconstruction - wrap in block
                // e.g., (a, b) => a + b  becomes { var (a, b) = arg0; return a + b; }
                body = $"{{\n            var ({paramPart}) = arg0;\n            return {body};\n        }}";
            }
            return body;
        }
        
        if (paramCount == 1)
        {
            // Single parameter - the whole paramPart is the name
            var originalName = paramPart.Trim();
            if (!string.IsNullOrEmpty(originalName) && originalName != "arg0")
            {
                // Use regex for whole-word replacement to avoid replacing substrings
                body = System.Text.RegularExpressions.Regex.Replace(
                    body, 
                    $@"\b{System.Text.RegularExpressions.Regex.Escape(originalName)}\b", 
                    "arg0");
            }
        }
        else
        {
            // Multiple parameters - split by comma
            var names = paramPart.Split(',').Select(n => n.Trim()).ToArray();
            for (int i = 0; i < names.Length && i < paramCount; i++)
            {
                var originalName = names[i];
                var newName = GetParameterName(i);
                if (!string.IsNullOrEmpty(originalName) && originalName != newName)
                {
                    body = System.Text.RegularExpressions.Regex.Replace(
                        body, 
                        $@"\b{System.Text.RegularExpressions.Regex.Escape(originalName)}\b", 
                        newName);
                }
            }
        }
        
        return body;
    }
    
    /// <summary>
    /// Infers the return type of a lambda expression from its body.
    /// Returns the type name in lowercase (e.g., "char", "boolean", "int32", "string") or null if unknown.
    /// </summary>
    private static string? InferReturnType(string lambdaSource)
    {
        // For method groups (no =>), we can't easily infer the return type
        if (!lambdaSource.Contains("=>"))
        {
            return null;
        }
        
        // Extract the body after =>
        var arrowIndex = lambdaSource.IndexOf("=>", StringComparison.Ordinal);
        if (arrowIndex < 0) return null;
        
        var body = lambdaSource.Substring(arrowIndex + 2).Trim();
        
        // Remove trailing semicolon if present
        if (body.EndsWith(";", StringComparison.Ordinal))
        {
            body = body.Substring(0, body.Length - 1).Trim();
        }
        
        // Check for common literal patterns
        
        // Boolean literals
        if (body == "true" || body == "false")
        {
            return "boolean";
        }
        
        // Char literal: 'x'
        if (body.Length >= 2 && body[0] == '\'' && body[body.Length - 1] == '\'')
        {
            return "char";
        }
        
        // String literal: "xxx"
        if (body.Length >= 2 && body[0] == '"' && body[body.Length - 1] == '"')
        {
            return "string";
        }
        
        // Integer literal (just digits, possibly with minus)
        if (System.Text.RegularExpressions.Regex.IsMatch(body, @"^-?\d+$"))
        {
            return "int32";
        }
        
        // Decimal/float literal (digits with . or f/m suffix)
        if (System.Text.RegularExpressions.Regex.IsMatch(body, @"^-?\d+\.\d+[fFdDmM]?$"))
        {
            if (body.EndsWith("f", StringComparison.OrdinalIgnoreCase))
                return "single";
            if (body.EndsWith("m", StringComparison.OrdinalIgnoreCase))
                return "decimal";
            return "double";
        }
        
        // new ClassName(...) - try to extract the type
        var newMatch = System.Text.RegularExpressions.Regex.Match(body, @"^new\s+([A-Za-z_][A-Za-z0-9_\.]*)\s*[\(\{]");
        if (newMatch.Success)
        {
            return newMatch.Groups[1].Value.ToLowerInvariant();
        }
        
        // Cast expression: (Type)expr
        var castMatch = System.Text.RegularExpressions.Regex.Match(body, @"^\(([A-Za-z_][A-Za-z0-9_\.]*)\)");
        if (castMatch.Success)
        {
            return castMatch.Groups[1].Value.ToLowerInvariant();
        }
        
        return null;
    }
}
