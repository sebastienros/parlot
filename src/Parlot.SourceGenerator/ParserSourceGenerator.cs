using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.IO;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Parlot.SourceGeneration;
using RoslynCompilation = Microsoft.CodeAnalysis.Compilation;

namespace Parlot.SourceGenerator;

/// <summary>
/// Incremental source generator for Parlot grammars.
///
/// It looks for static methods annotated with <see cref="GenerateParserAttribute"/> that:
///   - are static
///   - return Parlot.Fluent.Parser&lt;T&gt;
/// It then:
///   - builds a temporary compilation including those methods,
///   - executes the descriptor methods to obtain Parser&lt;T&gt; instances,
///   - invokes ISourceable.GenerateSource on those instances,
///   - and emits optimized parse methods plus small wrapper Parser&lt;T&gt; types.
/// </summary>
[Generator]
public sealed class ParserSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Find candidate methods syntactically (methods with attributes).
        var methodDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => IsCandidateMethod(node),
            static (syntaxContext, _) => GetMethodToGenerate(syntaxContext))
            .Where(static m => m is not null)!;

        // 2. Combine the collected methods with the current Compilation.
        var compilationAndMethods = context.CompilationProvider.Combine(methodDeclarations.Collect());

        // 3. Register for source output.
        context.RegisterSourceOutput(compilationAndMethods, static (spc, source) =>
        {
            var (compilation, methods) = source;
            
            // Always output a debug file to confirm this runs
            spc.AddSource("ParlotDebugInfo.g.cs", SourceText.From(
                "// <auto-generated />\n" +
                "// Methods count: " + (methods.IsDefaultOrEmpty ? "0" : methods.Length.ToString(System.Globalization.CultureInfo.InvariantCulture)) + "\n" +
                "namespace Parlot.SourceGenerator.Internal;\n" +
                "internal static class DebugInfo { }\n", Encoding.UTF8));

            if (methods.IsDefaultOrEmpty)
            {
                return;
            }

            foreach (var m in methods)
            {
                if (m is null)
                {
                    continue;
                }

                try
                {
                    GenerateForMethod(spc, compilation, m.Value);
                }
                catch (Exception ex)
                {
                    spc.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT005",
                            "Error generating parser source",
                            "An error occurred while generating parser source for method '{0}': {1}",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        m.Value.Method.Locations.FirstOrDefault(),
                        m.Value.Method.Name,
                        ex.Message));
                    continue;
                }
            }
        });
    }

    private static bool IsCandidateMethod(SyntaxNode node)
        => node is MethodDeclarationSyntax m && m.AttributeLists.Count > 0;

    private static MethodToGenerate? GetMethodToGenerate(GeneratorSyntaxContext context)
    {
        var methodDecl = (MethodDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        var methodSymbol = semanticModel.GetDeclaredSymbol(methodDecl) as IMethodSymbol;
        if (methodSymbol is null)
        {
            return null;
        }

        var compilation = semanticModel.Compilation;
        var generateParserAttrSymbol = compilation.GetTypeByMetadataName("Parlot.SourceGenerator.GenerateParserAttribute");
        if (generateParserAttrSymbol is null)
        {
            return null;
        }

        var attrInfos = ImmutableArray.CreateBuilder<GenerateParserAttributeInfo>();

        foreach (var attr in methodSymbol.GetAttributes())
        {
            if (!SymbolEqualityComparer.Default.Equals(attr.AttributeClass, generateParserAttrSymbol))
            {
                continue;
            }

            string? factoryMethodName = null;
            ImmutableArray<TypedConstant> args = ImmutableArray<TypedConstant>.Empty;

            if (attr.ConstructorArguments.Length >= 1)
            {
                var first = attr.ConstructorArguments[0];
                if (first.Value is string s && !string.IsNullOrEmpty(s))
                {
                    factoryMethodName = s;
                }
            }

            if (attr.ConstructorArguments.Length >= 2)
            {
                var argArray = attr.ConstructorArguments[1];
                if (argArray.Kind == TypedConstantKind.Array)
                {
                    args = argArray.Values;
                }
            }
            else
            {
                // Some overloads may store arguments via params object[] as a single array arg when invoked via object[] literal
                // e.g., [GenerateParser("Name", new object?[] { 1, 2 })]
                // In that case, ConstructorArguments.Length == 1 but the attribute overload selected is the string+params or parameterless one.
                // We only treat the first argument as factory name when it is a string; otherwise, for parameterless overload the args remain empty.
            }

            var location = attr.ApplicationSyntaxReference?.GetSyntax().GetLocation();
            attrInfos.Add(new GenerateParserAttributeInfo(factoryMethodName, args, location));
        }

        if (attrInfos.Count == 0)
        {
            return null;
        }

        if (!methodSymbol.IsStatic)
        {
            return null;
        }

        if (!IsParserReturnType(methodSymbol.ReturnType))
        {
            return null;
        }

        return new MethodToGenerate(methodSymbol, attrInfos.ToImmutable());
    }

    private readonly record struct MethodToGenerate(IMethodSymbol Method, ImmutableArray<GenerateParserAttributeInfo> Attributes);
    private readonly record struct GenerateParserAttributeInfo(string? FactoryMethodName, ImmutableArray<TypedConstant> Arguments, Location? Location);

    private static bool IsParserReturnType(ITypeSymbol returnType)
    {
        if (returnType is not INamedTypeSymbol named || !named.IsGenericType)
        {
            return false;
        }

        var constructedFrom = named.ConstructedFrom;
        var display = constructedFrom.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        // Expect "global::Parlot.Fluent.Parser<T>"
        return display == "global::Parlot.Fluent.Parser<T>";
    }

    [SuppressMessage("Build", "RS1035", Justification = "The generator must execute parser descriptors to produce source output.")]
    private static void GenerateForMethod(
        SourceProductionContext context,
        RoslynCompilation hostCompilation,
        MethodToGenerate methodInfo)
    {
        var methodSymbol = methodInfo.Method;

        // Validate attribute names are unique for this method
        if (!ValidateUniqueAttributeNames(methodInfo, context))
        {
            return;
        }

        // Get the syntax tree containing this method
        var methodSyntaxRef = methodSymbol.DeclaringSyntaxReferences.FirstOrDefault();
        if (methodSyntaxRef is null)
        {
            return;
        }
        var methodSyntaxTree = methodSyntaxRef.SyntaxTree;
        var methodSyntax = methodSyntaxRef.GetSyntax() as MethodDeclarationSyntax;
        
        // Extract all lambda expressions from the method for later matching
        var lambdaSources = new Dictionary<string, string>();
        if (methodSyntax is not null)
        {
            var lambdaIndex = 0;
            foreach (var lambda in methodSyntax.DescendantNodes().OfType<LambdaExpressionSyntax>())
            {
                // Store lambda with index-based key for simple matching
                lambdaSources[$"lambda_{lambdaIndex}"] = lambda.ToFullString().Trim();
                lambdaIndex++;
            }
        }

        // Create a minimal compilation with only the file containing the parser descriptor.
        // This avoids errors from other files that reference generated code.
        var minimalSyntaxTrees = new List<SyntaxTree> { methodSyntaxTree };
        
        // Add a synthetic file with global usings that Parlot and typical projects provide.
        // This ensures the dynamic compilation works even when the user relies on implicit usings.
        var parseOptions = (CSharpParseOptions)methodSyntaxTree.Options;
        var globalUsings = CSharpSyntaxTree.ParseText(
            """
            // Parlot global usings for source generator dynamic compilation
            global using System;
            global using System.Collections.Generic;
            global using System.Linq;
            global using System.Threading.Tasks;
            global using Parlot;
            global using Parlot.Fluent;
            global using static Parlot.Fluent.Parsers;
            """,
            parseOptions,
            path: "ParlotGlobalUsings.g.cs");
        minimalSyntaxTrees.Add(globalUsings);
        
        var tempCompilation = hostCompilation
            .RemoveAllSyntaxTrees()
            .AddSyntaxTrees(minimalSyntaxTrees)
            .WithAssemblyName(hostCompilation.AssemblyName + ".ParlotGenTemp")
            .WithOptions(hostCompilation.Options.WithOutputKind(OutputKind.DynamicallyLinkedLibrary));

        using var peStream = new System.IO.MemoryStream();
        var emitResult = tempCompilation.Emit(peStream);

        if (!emitResult.Success)
        {
            // Output a diagnostic about emit failure with the error messages
            var errorMessages = string.Join("; ", emitResult.Diagnostics
                .Where(d => d.Severity == DiagnosticSeverity.Error)
                .Take(5)
                .Select(d => d.GetMessage(System.Globalization.CultureInfo.InvariantCulture)));
            
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("PARLOT001", "Emit failed", "Emit failed for method '{0}': {1}", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name, errorMessages));
            return;
        }

        // Success message is Info-level (won't break build)
        context.ReportDiagnostic(Diagnostic.Create(
            new DiagnosticDescriptor("PARLOT000", "Emit succeeded", "Emit succeeded for method '{0}'", "Parlot.SourceGenerator", DiagnosticSeverity.Info, true),
            methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name));

        peStream.Position = 0;

        // Build a dictionary of assembly paths from the compilation's references
        // This allows us to load assemblies that the project references
        var assemblyPaths = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        var pendingCompilationRefs = new List<(string Name, RoslynCompilation Compilation)>();
        var loadedAssemblies = new Dictionary<string, Assembly>(StringComparer.OrdinalIgnoreCase);
        
        // Debug: collect reference info
        var refDebugInfo = new List<string>();

        // First pass: collect all references
        foreach (var reference in hostCompilation.References)
        {
            if (reference is PortableExecutableReference peRef && peRef.FilePath is not null)
            {
                var assemblyName = Path.GetFileNameWithoutExtension(peRef.FilePath);
                var filePath = peRef.FilePath;
                
                // If this is a ref assembly (in obj/*/ref/), try to find the actual assembly
                // Ref assemblies are metadata-only and can't be loaded at runtime
                if (filePath.Contains(Path.DirectorySeparatorChar + "ref" + Path.DirectorySeparatorChar) ||
                    filePath.Contains("/ref/"))
                {
                    // Try to find the actual assembly in bin folder
                    // Path like: .../obj/Debug/net10.0/ref/Samples.dll -> .../bin/Debug/net10.0/Samples.dll
                    var objIndex = filePath.LastIndexOf(Path.DirectorySeparatorChar + "obj" + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase);
                    if (objIndex < 0) objIndex = filePath.LastIndexOf("/obj/", StringComparison.OrdinalIgnoreCase);
                    
                    if (objIndex >= 0)
                    {
                        var baseDir = filePath.Substring(0, objIndex);
                        var afterObj = filePath.Substring(objIndex + 4); // Skip "/obj"
                        var refIndex = afterObj.IndexOf(Path.DirectorySeparatorChar + "ref" + Path.DirectorySeparatorChar, StringComparison.OrdinalIgnoreCase);
                        if (refIndex < 0) refIndex = afterObj.IndexOf("/ref/", StringComparison.OrdinalIgnoreCase);
                        
                        if (refIndex >= 0)
                        {
                            var configTfm = afterObj.Substring(0, refIndex); // e.g., "/Debug/net10.0"
                            var fileName = Path.GetFileName(filePath);
                            var binPath = baseDir + Path.DirectorySeparatorChar + "bin" + configTfm + Path.DirectorySeparatorChar + fileName;
                            
                            if (File.Exists(binPath))
                            {
                                filePath = binPath;
                            }
                        }
                    }
                }
                
                if (!assemblyPaths.ContainsKey(assemblyName))
                {
                    assemblyPaths[assemblyName] = filePath;
                }
                refDebugInfo.Add($"PE: {assemblyName} -> {filePath}");
            }
            else if (reference is CompilationReference compRef)
            {
                // For project references, we need to emit the referenced compilation to get an assembly
                var refCompilation = compRef.Compilation;
                var refAssemblyName = refCompilation.AssemblyName;
                refDebugInfo.Add($"Compilation: {refAssemblyName}");
                if (refAssemblyName is not null && refAssemblyName != "Parlot")
                {
                    pendingCompilationRefs.Add((refAssemblyName, refCompilation));
                }
            }
            else
            {
                refDebugInfo.Add($"Unknown: {reference.GetType().Name}");
            }
        }

        // Debug info removed - assembly loading working correctly

        // Set up an assembly resolver - needs to be set up BEFORE loading CompilationReference assemblies
        // because those assemblies may have their own dependencies
        ResolveEventHandler? resolver = null;
        resolver = (sender, args) =>
        {
            var requestedName = new AssemblyName(args.Name);
            if (requestedName.Name == "Parlot")
            {
                // Return the Parlot assembly that this generator is already using
                // This ensures ISourceable and other types have the same identity
                return typeof(Parlot.Fluent.Parser<>).Assembly;
            }

            // Try to return pre-loaded assembly from project references (CompilationReference)
            if (requestedName.Name is not null && loadedAssemblies.TryGetValue(requestedName.Name, out var loadedAssembly))
            {
                return loadedAssembly;
            }

            // Try to load from file-based references (PortableExecutableReference)
            if (requestedName.Name is not null && assemblyPaths.TryGetValue(requestedName.Name, out var path))
            {
                try
                {
                    var asm = Assembly.LoadFrom(path);
                    loadedAssemblies[requestedName.Name] = asm;
                    return asm;
                }
                catch
                {
                    // Fall through to return null
                }
            }

            return null;
        };

        AppDomain.CurrentDomain.AssemblyResolve += resolver;

        // Now load CompilationReference assemblies (with resolver active)
        foreach (var (refAssemblyName, refCompilation) in pendingCompilationRefs)
        {
            if (!loadedAssemblies.ContainsKey(refAssemblyName))
            {
                using var refPeStream = new MemoryStream();
                var refEmitResult = refCompilation.Emit(refPeStream);
                if (refEmitResult.Success)
                {
                    refPeStream.Position = 0;
                    try
                    {
                        var refAssembly = Assembly.Load(refPeStream.ToArray());
                        loadedAssemblies[refAssemblyName] = refAssembly;
                    }
                    catch (Exception ex)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            new DiagnosticDescriptor("PARLOT098", "Assembly load failed", "Failed to load '{0}': {1}", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                            methodSymbol.Locations.FirstOrDefault(), refAssemblyName, ex.Message));
                    }
                }
                else
                {
                    var errors = string.Join("; ", refEmitResult.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error).Take(3).Select(d => d.GetMessage(System.Globalization.CultureInfo.InvariantCulture)));
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor("PARLOT097", "Emit failed for ref", "Failed to emit '{0}': {1}", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                        methodSymbol.Locations.FirstOrDefault(), refAssemblyName, errors));
                }
            }
        }

        try
        {
            var assembly = Assembly.Load(peStream.ToArray());

            // Locate the generated type and method via reflection
            var containingTypeName = methodSymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            const string globalPrefix = "global::";
            if (containingTypeName.StartsWith(globalPrefix, StringComparison.Ordinal))
            {
                containingTypeName = containingTypeName.Substring(globalPrefix.Length);
            }

            var type = assembly.GetType(containingTypeName);
            if (type is null)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("PARLOT002", "Type not found", "Could not find type '{0}' in emitted assembly", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                    methodSymbol.Locations.FirstOrDefault(), containingTypeName));
                return;
            }

            var method = type.GetMethod(
                methodSymbol.Name,
                BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);

            if (method is null)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("PARLOT003", "Method not found", "Could not find method '{0}' on type '{1}'", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                    methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name, containingTypeName));
                return;
            }

            var methodParameters = method.GetParameters();

            var attributes = methodInfo.Attributes;
            for (int idx = 0; idx < attributes.Length; idx++)
            {
                var attrInfo = attributes[idx];
                var propertyName = attrInfo.FactoryMethodName;
                var variantSuffix = GetVariantSuffix(idx, propertyName);

                if (!TryBuildInvocationArguments(methodParameters, attrInfo.Arguments, methodSymbol, attrInfo.Location ?? methodSymbol.Locations.FirstOrDefault(), out var invocationArgs, out var diag))
                {
                    if (diag is not null)
                    {
                        context.ReportDiagnostic(diag);
                    }
                    continue;
                }

                object? parserInstance;
                try
                {
                    parserInstance = method.Invoke(null, invocationArgs);
                }
                catch (TargetInvocationException ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT004",
                            "Parser factory threw",
                            "Method '{0}' threw an exception while invoked with GenerateParser arguments: {1}",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        attrInfo.Location ?? methodSymbol.Locations.FirstOrDefault(),
                        methodSymbol.Name,
                        ex.InnerException?.Message ?? ex.Message));
                    continue;
                }
                catch (Exception ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT004",
                            "Parser factory failed",
                            "Method '{0}' could not be invoked: {1}",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        attrInfo.Location ?? methodSymbol.Locations.FirstOrDefault(),
                        methodSymbol.Name,
                        ex.Message));
                    continue;
                }

                if (parserInstance is null)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor("PARLOT004", "Null parser", "Method '{0}' returned null", "Parlot.SourceGenerator", DiagnosticSeverity.Warning, true),
                        attrInfo.Location ?? methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name));
                    continue;
                }

                // The runtime type will be something like Parlot.Fluent.Then`2 or similar,
                // whose base type is Parser<T>.
                var parserType = parserInstance.GetType();
                var baseType = parserType.BaseType;
                if (baseType is null || !baseType.IsGenericType)
                {
                    continue;
                }

                var valueType = baseType.GetGenericArguments()[0];

                // Ensure the parser supports source generation
                if (parserInstance is not ISourceable sourceable)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT001",
                            "Parser does not implement ISourceable",
                            "Parser type '{0}' does not implement ISourceable. Implemented interfaces: {1}",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Warning,
                            isEnabledByDefault: true),
                        attrInfo.Location ?? methodSymbol.Locations.FirstOrDefault(),
                        parserInstance.GetType().FullName,
                        string.Join(", ", parserInstance.GetType().GetInterfaces().Select(i => i.FullName))));
                    continue;
                }

                var sgContext = new SourceGenerationContext(parseContextName: "context", methodNamePrefix: methodSymbol.Name + "_" + variantSuffix);
                var sourceResult = sourceable.GenerateSource(sgContext);

                // Generate C# code for this particular attribute variant
                var sourceText = GenerateParserWrapperAndCore(methodSymbol, valueType, propertyName, variantSuffix, sourceResult, sgContext, lambdaSources);

                var hintName = $"{methodSymbol.ContainingType.Name}_{methodSymbol.Name}_{variantSuffix}.Parlot.g.cs";
                var dumpDirectory = Environment.GetEnvironmentVariable("PARLOT_DUMP_GEN_DIR");
                if (!string.IsNullOrEmpty(dumpDirectory))
                {
                    Directory.CreateDirectory(dumpDirectory);
                    File.WriteAllText(Path.Combine(dumpDirectory, hintName), sourceText);
                }
                context.AddSource(hintName, SourceText.From(sourceText, Encoding.UTF8));
            }
        }
        finally
        {
            AppDomain.CurrentDomain.AssemblyResolve -= resolver;
        }
    }

    private static string GenerateParserWrapperAndCore(
        IMethodSymbol methodSymbol,
        Type valueType,
        string? propertyName,
        string variantSuffix,
        SourceResult result,
        SourceGenerationContext sgContext,
        Dictionary<string, string> lambdaSources)
    {
        var ns = methodSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : methodSymbol.ContainingNamespace.ToDisplayString();

        var typeName = methodSymbol.ContainingType.Name;
        var methodName = methodSymbol.Name;
        var valueTypeName = TypeNameHelper.GetTypeName(valueType);
        var coreName = methodName + "_" + variantSuffix + "_Core";
        var wrapperName = "GeneratedParser_" + methodName + "_" + variantSuffix;

        // First pass: process all deferred parsers to collect all lambdas
        // We need to do this before emitting lambda fields
        var deferredMethods = new List<(string MethodName, string ValueTypeName, SourceResult Result)>();
        var processedDeferred = new HashSet<object>();
        var deferredToProcess = sgContext.Deferred.Enumerate().ToList();
        
        while (deferredToProcess.Count > 0)
        {
            var (parser, deferredMethodName) = deferredToProcess[0];
            deferredToProcess.RemoveAt(0);
            
            if (processedDeferred.Contains(parser))
            {
                continue;
            }
            processedDeferred.Add(parser);

            if (parser is not ISourceable sourceable)
            {
                continue;
            }

            // Get the parser type to determine how to process it
            var parserType = parser.GetType();
            
            // Find the result type from Parser<T> base class
            Type? deferredValueType = null;
            var currentType = parserType;
            while (currentType != null)
            {
                if (currentType.IsGenericType)
                {
                    var genericDef = currentType.GetGenericTypeDefinition();
                    if (genericDef.FullName == "Parlot.Fluent.Parser`1")
                    {
                        deferredValueType = currentType.GetGenericArguments()[0];
                        break;
                    }
                }
                currentType = currentType.BaseType;
            }

            if (deferredValueType is null)
            {
                continue;
            }

            var deferredValueTypeName = TypeNameHelper.GetTypeName(deferredValueType);

            // For Deferred<T> parsers, generate source for the inner parser
            // For other parsers (like Unary<T>), generate source for the parser itself
            SourceResult deferredResult;
            if (parserType.IsGenericType && parserType.GetGenericTypeDefinition().Name == "Deferred`1")
            {
                // Get the inner parser from the Deferred
                var parserProperty = parserType.GetProperty("Parser");
                if (parserProperty is null)
                {
                    continue;
                }

                var innerParser = parserProperty.GetValue(parser);
                if (innerParser is not ISourceable innerSourceable)
                {
                    continue;
                }

                // Generate source for the inner parser
                deferredResult = innerSourceable.GenerateSource(sgContext);
            }
            else
            {
                // For other deferred parsers (like Unary), generate source directly
                deferredResult = sourceable.GenerateSource(sgContext);
            }
            
            deferredMethods.Add((deferredMethodName, deferredValueTypeName, deferredResult));
            
            // Check for new deferred parsers that were added
            foreach (var newDeferred in sgContext.Deferred.Enumerate())
            {
                if (!processedDeferred.Contains(newDeferred.Parser) && !deferredToProcess.Any(d => d.Parser == newDeferred.Parser))
                {
                    deferredToProcess.Add(newDeferred);
                }
            }
        }

        // Collect helper methods (OneOf, etc.) after all parsers/deferred have been processed
        var helperMethods = sgContext.Helpers.Enumerate().ToList();

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable annotations");
        sb.AppendLine("#nullable disable warnings");
        sb.AppendLine("using System;");
        sb.AppendLine("using Parlot;");
        sb.AppendLine("using Parlot.Fluent;");

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine();
            sb.Append("namespace ").Append(ns).AppendLine();
            sb.AppendLine("{");
        }

        sb.AppendLine($"    partial class {typeName}");
        sb.AppendLine("    {");

        // Now emit lambda fields - this includes lambdas from both the main parser and all deferred parsers
        // We need to match lambdas by their signature since runtime traversal order may differ from source order
        var lambdaSourcesList = lambdaSources.OrderBy(kv => kv.Key).Select(kv => kv.Value).ToList();
        var registeredLambdas = sgContext.Lambdas.Enumerate().OrderBy(x => x.Id).ToList();
        
        // Track which source lambdas have been used
        var usedSourceIndices = new HashSet<int>();

        foreach (var (id, del) in registeredLambdas)
        {
            var fieldName = sgContext.GetLambdaFieldName(id);
            var delegateType = del.GetType();
            var delegateTypeName = TypeNameHelper.GetTypeName(delegateType);
            
            // Get delegate info for matching
            var invokeMethod = delegateType.GetMethod("Invoke");
            var paramCount = invokeMethod?.GetParameters().Length ?? 0;
            
            // Get parameter type names for matching
            var paramTypeNames = new List<string>();
            if (invokeMethod is not null)
            {
                foreach (var p in invokeMethod.GetParameters())
                {
                    paramTypeNames.Add(p.ParameterType.Name.ToLowerInvariant());
                }
            }
            
            // Try to find the best matching source lambda
            string? matchedSource = null;
            int bestMatchIndex = -1;
            int bestScore = -1;
            
            for (int i = 0; i < lambdaSourcesList.Count; i++)
            {
                if (usedSourceIndices.Contains(i))
                {
                    continue;
                }
                
                var lambdaSource = lambdaSourcesList[i];
                var sourceParamCount = CountLambdaParameters(lambdaSource);
                
                if (sourceParamCount != paramCount)
                {
                    continue;
                }
                
                // Calculate a score based on type name hints in the lambda
                int score = 0;
                var lowerLambda = lambdaSource.ToLowerInvariant();
                
                // Check for type hints in the lambda body
                foreach (var typeName_ in paramTypeNames)
                {
                    if (lowerLambda.Contains(typeName_))
                    {
                        score += 10;
                    }
                }
                
                // Prefer lambdas that haven't been used and match param count exactly
                score += (paramCount == sourceParamCount) ? 5 : 0;
                
                // Special case: check for "new Number" which takes decimal, or "new NegateExpression" which takes Expression
                if (paramTypeNames.Count == 1)
                {
                    if (paramTypeNames[0] == "decimal" && lowerLambda.Contains("new") && lowerLambda.Contains("number("))
                    {
                        score += 100;
                    }
                    else if (paramTypeNames[0] == "expression" && lowerLambda.Contains("negateexpression"))
                    {
                        score += 100;
                    }
                }
                
                if (score > bestScore)
                {
                    bestScore = score;
                    bestMatchIndex = i;
                    matchedSource = lambdaSource;
                }
            }
            
            if (matchedSource is not null && bestMatchIndex >= 0)
            {
                usedSourceIndices.Add(bestMatchIndex);
                sb.AppendLine($"        private static readonly {delegateTypeName} {fieldName} = {matchedSource};");
            }
            else
            {
                // Cannot generate source for external lambdas - emit error comment
                sb.AppendLine($"        // ERROR: Lambda {id} could not be extracted from source (param count: {paramCount}, types: {string.Join(", ", paramTypeNames)}).");
                sb.AppendLine($"        // This lambda may be from an external parser or was not found in the method's syntax tree.");
                sb.AppendLine($"        // To fix: define the parser inline in the [GenerateParser] method.");
                sb.AppendLine($"        private static readonly {delegateTypeName} {fieldName} = default!; // PLACEHOLDER - will cause runtime error");
            }
        }

        sb.AppendLine($"        private sealed class {wrapperName} : Parser<{valueTypeName}>");
        sb.AppendLine("        {");
        sb.AppendLine($"            public override bool Parse(ParseContext context, ref ParseResult<{valueTypeName}> result)");
        sb.AppendLine("            {");
        sb.AppendLine($"                return {coreName}(context, ref result);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"        internal static bool {coreName}(ParseContext context, ref ParseResult<{valueTypeName}> result)");
        sb.AppendLine("        {");
        sb.AppendLine("            var scanner = context.Scanner;");
        sb.AppendLine("            var cursor = scanner.Cursor;");
        
        // Always capture initial offset for parsers that don't skip whitespace
        if (result.ContentStartOffsetVariable == null)
        {
            sb.AppendLine("            var startOffset = cursor.Offset;");
        }
        
        sb.AppendLine();

        foreach (var local in result.Locals)
        {
            sb.Append("            ").AppendLine(local);
        }

        foreach (var stmt in result.Body)
        {
            sb.Append("            ").AppendLine(stmt);
        }

        sb.AppendLine();
        sb.AppendLine($"            if ({result.SuccessVariable})");
        sb.AppendLine("            {");
        
        // Use ContentStartOffsetVariable if available (for parsers that skip whitespace),
        // otherwise use the captured startOffset
        var startOffsetExpr = result.ContentStartOffsetVariable ?? "startOffset";
        
        sb.AppendLine($"                result = new ParseResult<{valueTypeName}>({startOffsetExpr}, cursor.Offset, {result.ValueVariable});");
        sb.AppendLine("                return true;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");

        // Emit helper methods for deferred parsers (already processed earlier)
        foreach (var (deferredMethodName, deferredValueTypeName, deferredResult) in deferredMethods)
        {
            sb.AppendLine();
            sb.AppendLine($"        private static global::System.ValueTuple<bool, {deferredValueTypeName}> {deferredMethodName}(ParseContext context)");
            sb.AppendLine("        {");
            sb.AppendLine("            var scanner = context.Scanner;");
            sb.AppendLine("            var cursor = scanner.Cursor;");
            sb.AppendLine();

            foreach (var local in deferredResult.Locals)
            {
                sb.Append("            ").AppendLine(local);
            }

            foreach (var stmt in deferredResult.Body)
            {
                sb.Append("            ").AppendLine(stmt);
            }

            sb.AppendLine();
            sb.AppendLine($"            return new global::System.ValueTuple<bool, {deferredValueTypeName}>({deferredResult.SuccessVariable}, {deferredResult.ValueVariable});");
            sb.AppendLine("        }");
        }

        // Emit helper methods registered via ParserHelperRegistry (e.g., OneOf buckets)
        foreach (var (helperMethodName, helperValueTypeName, helperResult) in helperMethods)
        {
            sb.AppendLine();
            sb.AppendLine($"        private static global::System.ValueTuple<bool, {helperValueTypeName}> {helperMethodName}(ParseContext context)");
            sb.AppendLine("        {");
            sb.AppendLine("            var scanner = context.Scanner;");
            sb.AppendLine("            var cursor = scanner.Cursor;");
            sb.AppendLine();

            foreach (var local in helperResult.Locals)
            {
                sb.Append("            ").AppendLine(local);
            }

            foreach (var stmt in helperResult.Body)
            {
                sb.Append("            ").AppendLine(stmt);
            }

            sb.AppendLine();
            sb.AppendLine($"            return new global::System.ValueTuple<bool, {helperValueTypeName}>({helperResult.SuccessVariable}, {helperResult.ValueVariable});");
            sb.AppendLine("        }");
        }
        sb.AppendLine();

        // Optional public factory, if the attribute specified one.
        if (!string.IsNullOrEmpty(propertyName))
        {
            sb.AppendLine();
            sb.AppendLine("        public static Parlot.Fluent.Parser<" + valueTypeName + "> " + propertyName + " { get; } = new " + wrapperName + "();");
        }
        else
        {
            sb.AppendLine();
            sb.AppendLine("        public static Parlot.Fluent.Parser<" + valueTypeName + "> " + methodName + "_Parser { get; } = new " + wrapperName + "();");
            sb.AppendLine();
        }

        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static bool ValidateUniqueAttributeNames(MethodToGenerate methodInfo, SourceProductionContext context)
    {
        var methodSymbol = methodInfo.Method;
        var attributes = methodInfo.Attributes;
        var nameMap = new Dictionary<string, GenerateParserAttributeInfo>(StringComparer.Ordinal);

        for (int i = 0; i < attributes.Length; i++)
        {
            var attr = attributes[i];
            var propName = attr.FactoryMethodName ?? (methodSymbol.Name + "_Parser");

            if (nameMap.TryGetValue(propName, out var existing))
            {
                var descriptor = new DiagnosticDescriptor(
                    "PARLOT010",
                    "Duplicate GenerateParser name",
                    "GenerateParser attributes on method '{0}' must have unique names. Duplicate name: '{1}'.",
                    "Parlot.SourceGenerator",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true);

                context.ReportDiagnostic(Diagnostic.Create(descriptor, attr.Location ?? methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name, propName));
                context.ReportDiagnostic(Diagnostic.Create(descriptor, existing.Location ?? methodSymbol.Locations.FirstOrDefault(), methodSymbol.Name, propName));
                return false;
            }

            nameMap[propName] = attr;
        }

        return true;
    }

    private static bool TryBuildInvocationArguments(
        ParameterInfo[] parameters,
        ImmutableArray<TypedConstant> arguments,
        IMethodSymbol methodSymbol,
        Location? location,
        out object?[] invocationArgs,
        out Diagnostic? diagnostic)
    {
        diagnostic = null;
        invocationArgs = Array.Empty<object?>();

        if (parameters.Length != arguments.Length)
        {
            diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    "PARLOT006",
                    "Argument count mismatch",
                    "GenerateParser arguments for method '{0}' did not match parameter count. Expected {1}, got {2}.",
                    "Parlot.SourceGenerator",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                location ?? methodSymbol.Locations.FirstOrDefault(),
                methodSymbol.Name,
                parameters.Length,
                arguments.Length);
            return false;
        }

        var args = new object?[arguments.Length];
        for (int i = 0; i < arguments.Length; i++)
        {
            var param = parameters[i];
            var paramType = param.ParameterType;
            var constant = arguments[i];
            var value = constant.Value;

            if (value is null)
            {
                if (paramType.IsValueType && Nullable.GetUnderlyingType(paramType) is null)
                {
                    diagnostic = Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT007",
                            "Null argument",
                            "GenerateParser argument for parameter '{0}' cannot be null.",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        location ?? methodSymbol.Locations.FirstOrDefault(),
                        param.Name ?? $"arg{i}");
                    return false;
                }

                args[i] = null;
                continue;
            }

            if (paramType.IsInstanceOfType(value))
            {
                args[i] = value;
                continue;
            }

            if (paramType == typeof(Type) && value is ITypeSymbol ts)
            {
                var typeDisplay = ts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var runtimeType = Type.GetType(typeDisplay);
                if (runtimeType is null)
                {
                    diagnostic = Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "PARLOT008",
                            "Type argument resolution failed",
                            "Could not resolve type '{0}' for parameter '{1}'.",
                            "Parlot.SourceGenerator",
                            DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        location ?? methodSymbol.Locations.FirstOrDefault(),
                        typeDisplay,
                        param.Name ?? $"arg{i}");
                    return false;
                }

                args[i] = runtimeType;
                continue;
            }

            try
            {
                // Attempt simple numeric/string conversions when possible
                args[i] = Convert.ChangeType(value, paramType, System.Globalization.CultureInfo.InvariantCulture);
                continue;
            }
            catch
            {
                diagnostic = Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "PARLOT009",
                        "Unsupported argument type",
                        "GenerateParser argument at position {0} (type '{1}') cannot be converted to parameter '{2}' of type '{3}'.",
                        "Parlot.SourceGenerator",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    location ?? methodSymbol.Locations.FirstOrDefault(),
                    i,
                    value.GetType().FullName,
                    param.Name ?? $"arg{i}",
                    paramType.FullName);
                return false;
            }
        }

        invocationArgs = args;
        return true;
    }

    private static string GetVariantSuffix(int index, string? propertyName)
    {
        var baseName = string.IsNullOrWhiteSpace(propertyName) ? "Parser" : propertyName!;
        return $"v{index}_{SanitizeIdentifier(baseName)}";
    }

    private static string SanitizeIdentifier(string raw)
    {
        if (string.IsNullOrEmpty(raw))
        {
            return "_";
        }

        var sb = new StringBuilder(raw.Length);
        for (int i = 0; i < raw.Length; i++)
        {
            var ch = raw[i];
            if ((ch >= 'a' && ch <= 'z') ||
                (ch >= 'A' && ch <= 'Z') ||
                (ch >= '0' && ch <= '9') ||
                ch == '_')
            {
                sb.Append(ch);
            }
            else
            {
                sb.Append('_');
            }
        }

        if (sb.Length == 0)
        {
            return "_";
        }

        if (sb[0] >= '0' && sb[0] <= '9')
        {
            sb.Insert(0, '_');
        }

        return sb.ToString();
    }

    /// <summary>
    /// Count parameters in a lambda expression source string.
    /// Examples:
    ///   "x => ..." -> 1
    ///   "(x) => ..." -> 1
    ///   "(a, b) => ..." -> 2
    ///   "() => ..." -> 0
    ///   "static x => ..." -> 1
    /// </summary>
    private static int CountLambdaParameters(string lambdaSource)
    {
        // Remove "static " prefix if present
        var source = lambdaSource.TrimStart();
        if (source.StartsWith("static ", StringComparison.Ordinal))
        {
            source = source.Substring(7).TrimStart();
        }

        // Find the arrow "=>"
        var arrowIndex = source.IndexOf("=>", StringComparison.Ordinal);
        if (arrowIndex < 0)
        {
            return 0;
        }

        var paramPart = source.Substring(0, arrowIndex).Trim();

        // Empty parameter list: () => ...
        if (paramPart == "()")
        {
            return 0;
        }

        // Single identifier without parens: x => ...
        if (!paramPart.StartsWith("(", StringComparison.Ordinal))
        {
            // It's a single identifier
            return 1;
        }

        // Has parentheses: (x) or (a, b) or (a, b, c)
        // Remove the parens
        if (paramPart.StartsWith("(", StringComparison.Ordinal) && paramPart.EndsWith(")", StringComparison.Ordinal))
        {
            paramPart = paramPart.Substring(1, paramPart.Length - 2).Trim();
        }

        if (string.IsNullOrEmpty(paramPart))
        {
            return 0;
        }

        // Count commas + 1
        var commaCount = paramPart.Count(c => c == ',');
        return commaCount + 1;
    }
}
